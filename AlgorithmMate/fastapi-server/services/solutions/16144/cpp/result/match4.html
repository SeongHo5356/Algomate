<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for solution_13.cpp & kjeng7897.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for solution_13.cpp & kjeng7897.cpp
      </h3>
      <h1 align="center">
        84.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>solution_13.cpp (73.809525%)<TH>kjeng7897.cpp (100.0%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match4-0.html#0',2,'match4-1.html#0',3)" NAME="0">(25-128)<TD><A HREF="javascript:ZweiFrames('match4-0.html#0',2,'match4-1.html#0',3)" NAME="0">(26-129)</A><TD ALIGN=center><FONT COLOR="#ff0000">124</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>solution_13.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;deque&gt;
#include&lt;set&gt;
#include&lt;unordered_set&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt; // srand(time(0))
#include&lt;regex&gt; // 정규표현식
#include&lt;random&gt; // rand
<A NAME="0"></A>#include&lt;complex&gt; // complex number
#include&lt;numeric&gt;
using namespace std;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match4-1.html#0',3,'match4-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;ll, ll&gt; pll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef complex&lt;double&gt; cpx;
#define pq priority_queue
#define endl &quot;\n&quot;

const ll INF = 1e18;
const int inf = 1e9;
const double pi = 3.14159265358979323846;

const string debug = &quot;output: &quot;;

struct VectorHasher {
    size_t operator()(const vector&lt;int&gt;&amp; V) const {
        size_t hash = V.size();
        for (auto&amp; i : V) {
            hash ^= i + 0x9e3779b9 + (hash &lt;&lt; 6) + (hash &gt;&gt; 2);
        }
        return hash;
    }
};

struct PiiHasher {
    size_t operator()(const pii&amp; x) const {
        return hash&lt;long long&gt;()(((long long)x.first) ^ (((long long)x.second) &lt;&lt; 32));
    }
};

ll gcd(ll a, ll b) {
    if (a &lt; b) swap(a, b);
    while (b != 0) {
        ll  n = a % b;
        a = b;
        b = n;
    }
    return a;
}

ll lcm(ll a, ll b) {
    ll g = gcd(a, b);
    return a / g * b;
}

ll powmod(ll x, ll n, ll mod) {
    if (n == 0) return 1;
    if (n % 2) return x * powmod(x, n - 1, mod) % mod;
    ll half = powmod(x, n / 2, mod);
    return half * half % mod;
}



ll modinv(ll x, ll mod) {
    return powmod(x, mod - 2, mod);
}


//const ll Fsize = 1;
//ll F[Fsize];
ll factorial(ll x) {
    ll ret = 1;
    //ret = F[x]; //
    return ret;
}

//ll modI[Fsize];  ll modIF[Fsize];
ll modinvfactorial(ll x) {
    ll ret = 1;
    //ret = modIF[x]; //
    return ret;
}

ll combination(ll n, ll r, ll mod) {
    if (r == 0 || n == r) return 1;
    return factorial(n) * modinvfactorial(n - r) % mod * modinvfactorial(r) % mod;
}

ll ccw(pll a, pll b, pll c) {
    ll ret = (b.first - a.first) * (c.second - a.second) - (c.first - a.first) * (b.second - a.second);
    if (ret &gt; 0) return 1;
    else if (ret == 0) return 0;
    else return -1;
}

bool intersect(pll A, pll B, pll C, pll D) { // 선분 교차 판정 A-B , C-D
    if (A &gt; B) swap(A, B);
    if (C &gt; D) swap(C, D);

    ll l1 = ccw(A, B, C) * ccw(A, B, D);
    ll l2 = ccw(C, D, A) * ccw(C, D, B);

    if (l1 == 0 &amp;&amp; l2 == 0) {
        return A &lt;= D &amp;&amp; C &lt;= B;
    }
    return l1 &lt;= 0 &amp;&amp; l2 &lt;= 0;
}



int dx[4] = { 0,1,0,-1};
int dy[4] = { 1,0,-1,0 };</B></FONT>
//int dx[8] = { -1,-1,-1,0,0,1,1,1 };
//int dy[8] = { -1,0,1,-1,1,-1,0,1 };

/////////////////////////////////////////////////////////////////////////////////////




void solve() {
    int N;
    cin &gt;&gt; N;
    vector &lt;long double&gt; arr(N);
    for (int i = 0; i &lt; N; i++) {
        cin &gt;&gt; arr[i];
    }
    long double l, r;
    l = 0;
    r = 300;
    for (int i = 1; i &lt; N; i++) {
        for (int j = 0; j &lt; i; j++) {
            l = max(l, (arr[i] - arr[j] - 1) / (i - j));
            r = min(r, (arr[i] - arr[j] + 1) / (i - j));
        }
    }
    if (l &lt; r) cout &lt;&lt; &quot;pass&quot;;
    else cout &lt;&lt; &quot;fail&quot;;

}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    int T = 1;
    //cin &gt;&gt; T;
    while (T--) {
        solve();
    }
    return 0;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>kjeng7897.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
##
#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;deque&gt;
#include&lt;set&gt;
#include&lt;unordered_set&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt; // srand(time(0))
#include&lt;regex&gt; // 정규표현식
#include&lt;random&gt; // rand
<A NAME="0"></A>#include&lt;complex&gt; // complex number
#include&lt;numeric&gt;
using namespace std;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4-0.html#0',2,'match4-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;ll, ll&gt; pll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef complex&lt;double&gt; cpx;
#define pq priority_queue
#define endl &quot;\n&quot;

const ll INF = 1e18;
const int inf = 1e9;
const double pi = 3.14159265358979323846;

const string debug = &quot;output: &quot;;

struct VectorHasher {
    size_t operator()(const vector&lt;int&gt;&amp; V) const {
        size_t hash = V.size();
        for (auto&amp; i : V) {
            hash ^= i + 0x9e3779b9 + (hash &lt;&lt; 6) + (hash &gt;&gt; 2);
        }
        return hash;
    }
};

struct PiiHasher {
    size_t operator()(const pii&amp; x) const {
        return hash&lt;long long&gt;()(((long long)x.first) ^ (((long long)x.second) &lt;&lt; 32));
    }
};

ll gcd(ll a, ll b) {
    if (a &lt; b) swap(a, b);
    while (b != 0) {
        ll  n = a % b;
        a = b;
        b = n;
    }
    return a;
}

ll lcm(ll a, ll b) {
    ll g = gcd(a, b);
    return a / g * b;
}

ll powmod(ll x, ll n, ll mod) {
    if (n == 0) return 1;
    if (n % 2) return x * powmod(x, n - 1, mod) % mod;
    ll half = powmod(x, n / 2, mod);
    return half * half % mod;
}



ll modinv(ll x, ll mod) {
    return powmod(x, mod - 2, mod);
}


//const ll Fsize = 1;
//ll F[Fsize];
ll factorial(ll x) {
    ll ret = 1;
    //ret = F[x]; //
    return ret;
}

//ll modI[Fsize];  ll modIF[Fsize];
ll modinvfactorial(ll x) {
    ll ret = 1;
    //ret = modIF[x]; //
    return ret;
}

ll combination(ll n, ll r, ll mod) {
    if (r == 0 || n == r) return 1;
    return factorial(n) * modinvfactorial(n - r) % mod * modinvfactorial(r) % mod;
}

ll ccw(pll a, pll b, pll c) {
    ll ret = (b.first - a.first) * (c.second - a.second) - (c.first - a.first) * (b.second - a.second);
    if (ret &gt; 0) return 1;
    else if (ret == 0) return 0;
    else return -1;
}

bool intersect(pll A, pll B, pll C, pll D) { // 선분 교차 판정 A-B , C-D
    if (A &gt; B) swap(A, B);
    if (C &gt; D) swap(C, D);

    ll l1 = ccw(A, B, C) * ccw(A, B, D);
    ll l2 = ccw(C, D, A) * ccw(C, D, B);

    if (l1 == 0 &amp;&amp; l2 == 0) {
        return A &lt;= D &amp;&amp; C &lt;= B;
    }
    return l1 &lt;= 0 &amp;&amp; l2 &lt;= 0;
}



int dx[4] = { 0,1,0,-1};
int dy[4] = { 1,0,-1,0 };</B></FONT>
//int dx[8] = { -1,-1,-1,0,0,1,1,1 };
//int dy[8] = { -1,0,1,-1,1,-1,0,1 };
</PRE>
</div>
  </div>
</body>
</html>
